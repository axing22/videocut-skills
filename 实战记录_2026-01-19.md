# 🎬 视频剪辑工作流 - 实战总结

**日期**: 2026-01-19
**视频**: 2026-01-19 20-16-37.mov (口播视频,12.3分钟)
**最终成果**: 2.5分钟精炼视频

---

## ✅ 成功方案

### 工具链

1. **Whisper large-v3** - 语音转文字(最佳开源模型)
2. **保留模式时间轴** - 用户手动标记要保留的内容
3. **FFmpeg** - 视频剪辑引擎

### 工作流程

```
原始视频 (12.3分钟)
    ↓
Whisper转录 → 185个自然句段
    ↓
生成"保留模式"时间轴
    ↓
用户标记核心内容 (65个段落 [x])
    ↓
FFmpeg剪辑 → 精炼视频 (2.5分钟)
```

---

## 📋 关键文件

### 1. 转录文件
- `2026-01-19 20-16-37_whisper_transcript.json` - Whisper转录结果
- 185个句子,带时间戳

### 2. 时间轴文件
- `时间轴_保留模式.md` - 用户手动标记
- 默认全部删除 `[ ]`
- 用户勾选保留 `[x]`

### 3. 输出视频
- `2026-01-19 20-16-37_保留剪辑_v2.mp4` - 最终精炼版

---

## 💡 核心经验

### 1. Whisper vs FunASR

| 特性 | Whisper large-v3 | FunASR |
|------|------------------|--------|
| 质量 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 分段 | 自然句子(好) | 字符级(碎) |
| 时间戳 | 精确 | 精确 |
| 速度 | 慢(12分钟→50分钟) | 快 |
| **适用场景** | **视频剪辑** | 字幕生成 |

**结论**: 视频剪辑用 Whisper,分段更合理!

### 2. 保留模式 > 删除模式

**删除模式的问题**:
- 用户要标记185个里面删哪些
- 太多选择,容易漏标
- 心理负担重

**保留模式的优势**:
- 用户只选核心内容
- 精选20-30%(65个段落)
- 结果可控,质量高

### 3. 正则表达式陷阱

❌ **错误**: 严格匹配格式
```python
pattern = r'\*\*\s+(\d+)\.\*\*\s+\[\s*([\d.]+)s\s+-\s+([\d.]+)s\].*?\[\s*([x\s\]]+)\]'
```
只匹配到99/185段

✅ **正确**: 分步提取
```python
# 1. 找时间范围
time_match = re.search(r'\[\s*([\d.]+)s\s+-\s+([\d.]+)s\]', line)
# 2. 找标记
marker_match = re.search(r'\[([ x\]]*)\]', after_time)
```
匹配到185/185段

**教训**: 正则太严格会漏数据!分步提取更可靠。

---

## 🎯 最终效果

- **压缩比**: 80% (12.3分钟 → 2.5分钟)
- **信息密度**: 高
- **适合平台**: 抖音、视频号、小红书

---

## 📝 脚本清单

### 核心脚本

1. `transcribe_whisper.py` - Whisper转录
2. `generate_whisper_timeline.py` - 生成时间轴
3. `execute_keep_edit_fixed.py` - 执行剪辑

### 关键代码

#### 保留模式时间轴生成
```python
# 默认全部[ ] (删除)
for seg in segments:
    timeline += f"**{i}.** [{seg['start']}s - {seg['end']}s] [ ] {seg['text']}\n"
```

#### 解析保留标记
```python
# 宽松匹配
for line in lines:
    if not line.startswith('**'): continue

    time_match = re.search(r'\[([\d.]+)s\s+-\s+([\d.]+)s\]', line)
    marker_match = re.search(r'\[([ x\]]*)\]', line[time_match.end():])

    if 'x' in marker_match.group(1):
        keep_ranges.append((start, end, idx))
```

#### FFmpeg剪辑
```python
# 生成filter
for i, (start, end) in enumerate(keep_ranges):
    filters.append(f"[0:v]trim=start={start}:end={end},setpts=PTS-STARTPTS[v{i}]")
    filters.append(f"[0:a]atrim=start={start}:end={end},asetpts=PTS-STARTPTS[a{i}]")

# concat
filter_complex = f"{all_inputs}concat=n={len(keep_ranges)}:v=1:a=1[outv][outa]"
```

---

## 🚀 优化方向

1. **GPU加速** - Whisper在GPU上快10倍
2. **交互式UI** - Web界面拖拽编辑
3. **自动推荐** - AI自动建议保留哪些段落
4. **实时预览** - 剪辑前预览效果

---

## 📌 记录日

2026-01-19:
- ✅ 验证了Whisper large-v3的质量
- ✅ 确立了"保留模式"工作流
- ✅ 解决了正则表达式匹配问题
- ✅ 成功剪辑12.3分钟 → 2.5分钟
- ⏱️ 总耗时: ~1小时(转录50分钟+剪辑10分钟)

---

## 🎓 经验教训

1. **不要试图全自动** - AI推荐,人工决策
2. **保留模式更符合直觉** - 选要留的,不是选要删的
3. **分段质量很重要** - Whisper的自然句子分段最好
4. **正则要宽松** - 宁可多匹配,后期过滤
5. **用户体验第一** - 可视化时间轴 > 命令行

---

**下次优化**: 添加自动推荐功能,让AI预选核心内容,用户只需确认。